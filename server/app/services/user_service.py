from fastapi import HTTPException, status
from datetime import datetime
from typing import Optional, Dict, Any
import random

from ..database.database import SessionLocal
from ..models.user import User
from ..schemas.auth import UserCreate
from ..schemas.user_profile import UserUpdate

from passlib.context import CryptContext


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class UserService:
    """
    Service x·ª≠ l√Ω logic li√™n quan ƒë·∫øn User
    """
    
    def __init__(self):
        self.db = SessionLocal()
    
    def __del__(self):
        self.db.close()
    
    async def get_user_by_id(self, user_id: int) -> Optional[User]:
        """
        L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo ID
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = self.db.query(User).filter(User.id == user_id).first()
        
        # N·∫øu user kh√¥ng t·ªìn t·∫°i, tr·∫£ v·ªÅ None
        if not user:
            return None
            
        # Ki·ªÉm tra xem user c√≥ d·ªØ li·ªáu stats v√† learning_progress ch∆∞a, n·∫øu ch∆∞a th√¨ th√™m v√†o
        if not hasattr(user, 'stats') or user.stats is None:
            user.stats = {
                "completed_exercises": 0,
                "completed_courses": 0,
                "total_points": 0,
                "streak_days": 0,
                "level": 1,
                "problems_solved": 0
            }
            
        if not hasattr(user, 'learning_progress') or user.learning_progress is None:
            user.learning_progress = {
                "algorithms": 0,
                "data_structures": 0,
                "dynamic_programming": 0
            }
            
        # L∆∞u l·∫°i v√†o database n·∫øu c√≥ thay ƒë·ªïi
        self.db.commit()
        
        return user
    
    async def get_user_by_email(self, email: str) -> Optional[User]:
        """
        L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo email
        
        Args:
            email (str): Email c·ªßa ng∆∞·ªùi d√πng
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        return self.db.query(User).filter(User.email == email).first()
    
    async def get_user_by_username(self, username: str) -> Optional[User]:
        """
        L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo username
        
        Args:
            username (str): Username c·ªßa ng∆∞·ªùi d√πng
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        return self.db.query(User).filter(User.username == username).first()
    
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """
        Ki·ªÉm tra m·∫≠t kh·∫©u
        
        Args:
            plain_password (str): M·∫≠t kh·∫©u g·ªëc
            hashed_password (str): M·∫≠t kh·∫©u ƒë√£ m√£ h√≥a
            
        Returns:
            bool: True n·∫øu m·∫≠t kh·∫©u ƒë√∫ng, ng∆∞·ª£c l·∫°i l√† False
        """
        return pwd_context.verify(plain_password, hashed_password)
    
    def get_password_hash(self, password: str) -> str:
        """
        M√£ h√≥a m·∫≠t kh·∫©u
        
        Args:
            password (str): M·∫≠t kh·∫©u g·ªëc
            
        Returns:
            str: M·∫≠t kh·∫©u ƒë√£ m√£ h√≥a
        """
        return pwd_context.hash(password)
    
    async def create_user(self, user_data: UserCreate) -> User:
        """
        T·∫°o ng∆∞·ªùi d√πng m·ªõi
        
        Args:
            user_data (UserCreate): Th√¥ng tin ng∆∞·ªùi d√πng m·ªõi
            
        Returns:
            User: Ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c t·∫°o
            
        Raises:
            HTTPException: N·∫øu email ho·∫∑c username ƒë√£ t·ªìn t·∫°i
        """
        # Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
        db_user = await self.get_user_by_email(user_data.email)
        if db_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng"
            )
        
        # Ki·ªÉm tra username ƒë√£ t·ªìn t·∫°i ch∆∞a
        db_user = await self.get_user_by_username(user_data.username)
        if db_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng"
            )
        
        # M√£ h√≥a m·∫≠t kh·∫©u
        hashed_password = self.get_password_hash(user_data.password)
        
        # T·∫°o ng∆∞·ªùi d√πng m·ªõi
        now = datetime.utcnow()
        new_user = User(
            email=user_data.email,
            username=user_data.username,
            hashed_password=hashed_password,
            first_name=user_data.first_name,
            last_name=user_data.last_name,
            avatar_url=f"/avatars/default-{random.randint(1, 5)}.png",
            created_at=now,
            updated_at=now,
            stats={
                "completed_exercises": 0,
                "completed_courses": 0,
                "total_points": 0,
                "streak_days": 0,
                "level": 1,
                "problems_solved": 0
            },
            badges=[
                {
                    "id": 1,
                    "name": "Ng∆∞·ªùi m·ªõi",
                    "icon": "üî∞",
                    "description": "Ho√†n th√†nh ƒëƒÉng k√Ω t√†i kho·∫£n",
                    "unlocked": True
                }
            ],
            activities=[],
            learning_progress={
                "algorithms": 0,
                "data_structures": 0,
                "dynamic_programming": 0
            },
            courses=[]
        )
        
        # L∆∞u v√†o database
        self.db.add(new_user)
        self.db.commit()
        self.db.refresh(new_user)
        
        return new_user
    
    async def update_password(self, user_id: int, new_password: str) -> bool:
        """
        C·∫≠p nh·∫≠t m·∫≠t kh·∫©u cho ng∆∞·ªùi d√πng
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            new_password (str): M·∫≠t kh·∫©u m·ªõi
            
        Returns:
            bool: True n·∫øu c·∫≠p nh·∫≠t th√†nh c√¥ng, ng∆∞·ª£c l·∫°i l√† False
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return False
        
        # M√£ h√≥a m·∫≠t kh·∫©u m·ªõi
        hashed_password = self.get_password_hash(new_password)
        
        # C·∫≠p nh·∫≠t m·∫≠t kh·∫©u
        user.hashed_password = hashed_password
        user.updated_at = datetime.utcnow()
        
        # L∆∞u v√†o database
        self.db.commit()
        
        return True
    
    async def update_user_profile(self, user_id: int, profile_data: UserUpdate) -> Optional[User]:
        """
        C·∫≠p nh·∫≠t th√¥ng tin profile c·ªßa ng∆∞·ªùi d√πng
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            profile_data (UserUpdate): Th√¥ng tin profile m·ªõi
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return None
        
        # C·∫≠p nh·∫≠t th√¥ng tin
        for key, value in profile_data.dict(exclude_unset=True).items():
            setattr(user, key, value)
        
        user.updated_at = datetime.utcnow()
        
        # L∆∞u v√†o database
        self.db.commit()
        self.db.refresh(user)
        
        return user
    
    async def add_activity(self, user_id: int, activity_data: Dict[str, Any]) -> Optional[User]:
        """
        Th√™m ho·∫°t ƒë·ªông m·ªõi v√†o profile c·ªßa ng∆∞·ªùi d√πng
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            activity_data (Dict[str, Any]): Th√¥ng tin ho·∫°t ƒë·ªông m·ªõi
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return None
        
        # T·∫°o ID cho ho·∫°t ƒë·ªông m·ªõi
        activities = user.activities if user.activities else []
        activity_id = len(activities) + 1
        
        # T·∫°o chu·ªói ƒë·ªãnh d·∫°ng ng√†y th√°ng
        activity_date = datetime.now().strftime("%d/%m/%Y")
        
        # T·∫°o ho·∫°t ƒë·ªông m·ªõi
        activity = {
            "id": activity_id,
            "type": activity_data.get("type"),
            "name": activity_data.get("name"),
            "date": activity_date
        }
        
        # Th√™m th√¥ng tin t√πy ch·ªçn
        if "score" in activity_data:
            activity["score"] = activity_data["score"]
        if "progress" in activity_data:
            activity["progress"] = activity_data["progress"]
        
        # Th√™m ho·∫°t ƒë·ªông m·ªõi
        activities.append(activity)
        user.activities = activities
        
        # C·∫≠p nh·∫≠t th·ªëng k√™
        await self._update_stats_after_activity(user, activity_data)
        
        # L∆∞u v√†o database
        user.updated_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(user)
        
        return user
    
    async def add_badge(self, user_id: int, badge_data: Dict[str, Any]) -> Optional[User]:
        """
        Th√™m huy hi·ªáu m·ªõi v√†o profile c·ªßa ng∆∞·ªùi d√πng
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            badge_data (Dict[str, Any]): Th√¥ng tin huy hi·ªáu m·ªõi
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return None
        
        badges = user.badges if user.badges else []
        
        # Ki·ªÉm tra huy hi·ªáu ƒë√£ t·ªìn t·∫°i ch∆∞a
        badge_id = badge_data.get("id")
        for i, badge in enumerate(badges):
            if badge.get("id") == badge_id:
                # C·∫≠p nh·∫≠t tr·∫°ng th√°i huy hi·ªáu ƒë√£ c√≥
                badges[i]["unlocked"] = badge_data.get("unlocked", True)
                user.badges = badges
                user.updated_at = datetime.utcnow()
                self.db.commit()
                self.db.refresh(user)
                return user
        
        # Th√™m huy hi·ªáu m·ªõi
        badge = {
            "id": badge_id,
            "name": badge_data.get("name"),
            "icon": badge_data.get("icon"),
            "description": badge_data.get("description"),
            "unlocked": badge_data.get("unlocked", True)
        }
        
        badges.append(badge)
        user.badges = badges
        
        # L∆∞u v√†o database
        user.updated_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(user)
        
        return user
    
    async def update_learning_progress(self, user_id: int, progress_data: Dict[str, int]) -> Optional[User]:
        """
        C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô h·ªçc t·∫≠p c·ªßa ng∆∞·ªùi d√πng
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            progress_data (Dict[str, int]): Th√¥ng tin ti·∫øn ƒë·ªô h·ªçc t·∫≠p m·ªõi
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return None
        
        # C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô h·ªçc t·∫≠p
        learning_progress = user.learning_progress if user.learning_progress else {}
        for key, value in progress_data.items():
            learning_progress[key] = value
        
        user.learning_progress = learning_progress
        
        # L∆∞u v√†o database
        user.updated_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(user)
        
        return user
    
    async def update_course_progress(self, user_id: int, course_id: str, progress: int) -> Optional[User]:
        """
        C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô kh√≥a h·ªçc
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            course_id (str): ID c·ªßa kh√≥a h·ªçc
            progress (int): Ti·∫øn ƒë·ªô m·ªõi (0-100%)
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return None
        
        # L·∫•y danh s√°ch kh√≥a h·ªçc
        courses = user.courses if user.courses else []
        
        # Ki·ªÉm tra kh√≥a h·ªçc ƒë√£ t·ªìn t·∫°i ch∆∞a
        for i, course in enumerate(courses):
            if course.get("id") == course_id:
                # C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô
                courses[i]["progress"] = progress
                
                # Ki·ªÉm tra ho√†n th√†nh kh√≥a h·ªçc
                if progress >= 100 and courses[i].get("progress", 0) < 100:
                    # C·∫≠p nh·∫≠t th·ªëng k√™
                    stats = user.stats if user.stats else {}
                    stats["completed_courses"] = stats.get("completed_courses", 0) + 1
                    user.stats = stats
                
                user.courses = courses
                user.updated_at = datetime.utcnow()
                self.db.commit()
                self.db.refresh(user)
                return user
        
        # Kh√¥ng t√¨m th·∫•y kh√≥a h·ªçc, tr·∫£ v·ªÅ None
        return None
    
    async def _update_stats_after_activity(self, user: User, activity_data: Dict[str, Any]) -> None:
        """
        C·∫≠p nh·∫≠t th·ªëng k√™ sau khi c√≥ ho·∫°t ƒë·ªông m·ªõi
        
        Args:
            user (User): Th√¥ng tin ng∆∞·ªùi d√πng
            activity_data (Dict[str, Any]): Th√¥ng tin ho·∫°t ƒë·ªông m·ªõi
        """
        stats = user.stats if user.stats else {}
        activity_type = activity_data.get("type")
        
        if activity_type == "exercise":
            # B√†i t·∫≠p ho√†n th√†nh
            stats["completed_exercises"] = stats.get("completed_exercises", 0) + 1
            stats["total_points"] = stats.get("total_points", 0) + 10
            
            # Ki·ªÉm tra n·∫øu l√† b√†i t·∫≠p code
            if "code" in activity_data.get("tags", []):
                stats["problems_solved"] = stats.get("problems_solved", 0) + 1
        
        elif activity_type == "course":
            # Kh√≥a h·ªçc ho√†n th√†nh
            if activity_data.get("completed"):
                stats["completed_courses"] = stats.get("completed_courses", 0) + 1
                stats["total_points"] = stats.get("total_points", 0) + 50
        
        # C·∫≠p nh·∫≠t level n·∫øu c·∫ßn
        await self._update_level(user, stats)
        
        # L∆∞u l·∫°i th·ªëng k√™
        user.stats = stats
    
    async def _update_level(self, user: User, stats: Dict[str, Any]) -> None:
        """
        C·∫≠p nh·∫≠t level c·ªßa ng∆∞·ªùi d√πng d·ª±a tr√™n ƒëi·ªÉm s·ªë
        
        Args:
            user (User): Th√¥ng tin ng∆∞·ªùi d√πng
            stats (Dict[str, Any]): Th·ªëng k√™ ng∆∞·ªùi d√πng
        """
        total_points = stats.get("total_points", 0)
        current_level = stats.get("level", 1)
        
        # C√¥ng th·ª©c t√≠nh level: level = 1 + floor(sqrt(points / 100))
        new_level = 1 + int((total_points / 100) ** 0.5)
        
        if new_level > current_level:
            stats["level"] = new_level
            
            # T·∫°o ho·∫°t ƒë·ªông l√™n c·∫•p
            await self.add_activity(user.id, {
                "type": "level_up",
                "name": f"L√™n c·∫•p {new_level}",
                "completed": True
            })
            
            # Ki·ªÉm tra v√† c·∫•p huy hi·ªáu (n·∫øu c·∫ßn)
            await self._check_level_badge(user)
    
    async def update_streak(self, user_id: int) -> Optional[User]:
        """
        C·∫≠p nh·∫≠t chu·ªói ng√†y ho·∫°t ƒë·ªông li√™n ti·∫øp (streak)
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return None
        
        # L·∫•y th·ªëng k√™ hi·ªán t·∫°i
        stats = user.stats if user.stats else {}
        
        # Ki·ªÉm tra ng√†y cu·ªëi c√πng ƒë√£ ho·∫°t ƒë·ªông
        last_active_date = stats.get("last_active_date")
        today = datetime.utcnow().date()
        
        if last_active_date:
            # Chuy·ªÉn ƒë·ªãnh d·∫°ng ng√†y
            if isinstance(last_active_date, str):
                last_active_date = datetime.strptime(last_active_date, "%Y-%m-%d").date()
            
            # T√≠nh s·ªë ng√†y gi·ªØa l·∫ßn ho·∫°t ƒë·ªông cu·ªëi v√† hi·ªán t·∫°i
            days_diff = (today - last_active_date).days
            
            if days_diff == 1:
                # Ho·∫°t ƒë·ªông li√™n ti·∫øp, tƒÉng streak
                stats["streak_days"] = stats.get("streak_days", 0) + 1
            elif days_diff > 1:
                # M·∫•t streak, ƒë·∫∑t l·∫°i
                stats["streak_days"] = 1
            # N·∫øu days_diff = 0, gi·ªØ nguy√™n streak
        else:
            # L·∫ßn ƒë·∫ßu ho·∫°t ƒë·ªông
            stats["streak_days"] = 1
        
        # C·∫≠p nh·∫≠t ng√†y ho·∫°t ƒë·ªông
        stats["last_active_date"] = today.isoformat()
        
        # L∆∞u l·∫°i th·ªëng k√™
        user.stats = stats
        user.updated_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(user)
        
        # Ki·ªÉm tra v√† c·∫•p huy hi·ªáu (n·∫øu c·∫ßn)
        await self._check_streak_badge(user)
        
        return user
    
    async def _check_streak_badge(self, user: User) -> None:
        """
        Ki·ªÉm tra v√† c·∫•p huy hi·ªáu li√™n quan ƒë·∫øn streak
        
        Args:
            user (User): Th√¥ng tin ng∆∞·ªùi d√πng
        """
        stats = user.stats if user.stats else {}
        streak_days = stats.get("streak_days", 0)
        
        # Danh s√°ch huy hi·ªáu streak
        streak_badges = [
            {
                "id": 10,
                "name": "ChƒÉm ch·ªâ",
                "icon": "üî•",
                "description": "Ho·∫°t ƒë·ªông li√™n t·ª•c 7 ng√†y",
                "threshold": 7
            },
            {
                "id": 11,
                "name": "Ki√™n tr√¨",
                "icon": "‚ö°",
                "description": "Ho·∫°t ƒë·ªông li√™n t·ª•c 30 ng√†y",
                "threshold": 30
            },
            {
                "id": 12,
                "name": "Si√™u nh√¢n",
                "icon": "üöÄ",
                "description": "Ho·∫°t ƒë·ªông li√™n t·ª•c 100 ng√†y",
                "threshold": 100
            }
        ]
        
        # Ki·ªÉm tra t·ª´ng huy hi·ªáu
        for badge_data in streak_badges:
            if streak_days >= badge_data["threshold"]:
                # X√≥a tr∆∞·ªùng threshold tr∆∞·ªõc khi th√™m huy hi·ªáu
                badge_info = {k: v for k, v in badge_data.items() if k != "threshold"}
                await self.add_badge(user.id, badge_info)
    
    async def _check_level_badge(self, user: User) -> None:
        """
        Ki·ªÉm tra v√† c·∫•p huy hi·ªáu li√™n quan ƒë·∫øn level
        
        Args:
            user (User): Th√¥ng tin ng∆∞·ªùi d√πng
        """
        stats = user.stats if user.stats else {}
        level = stats.get("level", 1)
        
        # Danh s√°ch huy hi·ªáu level
        level_badges = [
            {
                "id": 20,
                "name": "T√¢n binh",
                "icon": "üå±",
                "description": "ƒê·∫°t c·∫•p ƒë·ªô 5",
                "threshold": 5
            },
            {
                "id": 21,
                "name": "Chi·∫øn binh",
                "icon": "‚öîÔ∏è",
                "description": "ƒê·∫°t c·∫•p ƒë·ªô 10",
                "threshold": 10
            },
            {
                "id": 22,
                "name": "B·∫≠c th·∫ßy",
                "icon": "üèÜ",
                "description": "ƒê·∫°t c·∫•p ƒë·ªô 20",
                "threshold": 20
            }
        ]
        
        # Ki·ªÉm tra t·ª´ng huy hi·ªáu
        for badge_data in level_badges:
            if level >= badge_data["threshold"]:
                # X√≥a tr∆∞·ªùng threshold tr∆∞·ªõc khi th√™m huy hi·ªáu
                badge_info = {k: v for k, v in badge_data.items() if k != "threshold"}
                await self.add_badge(user.id, badge_info)
    
    async def update_badges(self, user_id: int) -> Optional[User]:
        """
        C·∫≠p nh·∫≠t v√† ki·ªÉm tra c√°c huy hi·ªáu cho ng∆∞·ªùi d√πng
        
        Args:
            user_id (int): ID c·ªßa ng∆∞·ªùi d√πng
            
        Returns:
            Optional[User]: Th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ c·∫≠p nh·∫≠t ho·∫∑c None n·∫øu kh√¥ng t√¨m th·∫•y
        """
        user = await self.get_user_by_id(user_id)
        if not user:
            return None
        
        # Ki·ªÉm tra c√°c lo·∫°i huy hi·ªáu
        await self._check_streak_badge(user)
        await self._check_level_badge(user)
        await self._check_problem_solved_badge(user)
        await self._check_account_age_badge(user)
        
        return user
    
    async def _check_problem_solved_badge(self, user: User) -> None:
        """
        Ki·ªÉm tra v√† c·∫•p huy hi·ªáu li√™n quan ƒë·∫øn s·ªë b√†i gi·∫£i ƒë∆∞·ª£c
        
        Args:
            user (User): Th√¥ng tin ng∆∞·ªùi d√πng
        """
        stats = user.stats if user.stats else {}
        problems_solved = stats.get("problems_solved", 0)
        
        # Danh s√°ch huy hi·ªáu problems_solved
        problem_badges = [
            {
                "id": 30,
                "name": "Coder t·∫≠p s·ª±",
                "icon": "üíª",
                "description": "Gi·∫£i ƒë∆∞·ª£c 10 b√†i t·∫≠p",
                "threshold": 10
            },
            {
                "id": 31,
                "name": "Coder chuy√™n nghi·ªáp",
                "icon": "üë®‚Äçüíª",
                "description": "Gi·∫£i ƒë∆∞·ª£c 50 b√†i t·∫≠p",
                "threshold": 50
            },
            {
                "id": 32,
                "name": "Coder huy·ªÅn tho·∫°i",
                "icon": "üßô‚Äç‚ôÇÔ∏è",
                "description": "Gi·∫£i ƒë∆∞·ª£c 100 b√†i t·∫≠p",
                "threshold": 100
            }
        ]
        
        # Ki·ªÉm tra t·ª´ng huy hi·ªáu
        for badge_data in problem_badges:
            if problems_solved >= badge_data["threshold"]:
                # X√≥a tr∆∞·ªùng threshold tr∆∞·ªõc khi th√™m huy hi·ªáu
                badge_info = {k: v for k, v in badge_data.items() if k != "threshold"}
                await self.add_badge(user.id, badge_info)
    
    async def _check_account_age_badge(self, user: User) -> None:
        """
        Ki·ªÉm tra v√† c·∫•p huy hi·ªáu li√™n quan ƒë·∫øn tu·ªïi t√†i kho·∫£n
        
        Args:
            user (User): Th√¥ng tin ng∆∞·ªùi d√πng
        """
        if not user.created_at:
            return
        
        # T√≠nh s·ªë ng√†y k·ªÉ t·ª´ khi t·∫°o t√†i kho·∫£n
        account_age_days = (datetime.utcnow() - user.created_at).days
        
        # Danh s√°ch huy hi·ªáu account_age
        age_badges = [
            {
                "id": 40,
                "name": "Th√†nh vi√™n m·ªõi",
                "icon": "üë∂",
                "description": "T√†i kho·∫£n ƒë√£ t·ªìn t·∫°i 30 ng√†y",
                "threshold": 30
            },
            {
                "id": 41,
                "name": "Th√†nh vi√™n trung th√†nh",
                "icon": "üë®",
                "description": "T√†i kho·∫£n ƒë√£ t·ªìn t·∫°i 180 ng√†y",
                "threshold": 180
            },
            {
                "id": 42,
                "name": "Th√†nh vi√™n l√¢u nƒÉm",
                "icon": "üë¥",
                "description": "T√†i kho·∫£n ƒë√£ t·ªìn t·∫°i 365 ng√†y",
                "threshold": 365
            }
        ]
        
        # Ki·ªÉm tra t·ª´ng huy hi·ªáu
        for badge_data in age_badges:
            if account_age_days >= badge_data["threshold"]:
                # X√≥a tr∆∞·ªùng threshold tr∆∞·ªõc khi th√™m huy hi·ªáu
                badge_info = {k: v for k, v in badge_data.items() if k != "threshold"}
                await self.add_badge(user.id, badge_info) 