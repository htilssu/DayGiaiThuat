from typing import Dict, Any

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from sqlalchemy.orm import selectinload

from ..database.database import get_async_db
from ..models import (
    Badge,
    User,
    UserBadge,
    UserCourse,
    Course,
    UserCourseProgress,
    UserState,
    UserActivity,
    UserTopicProgress,
    Topic,
)
from ..models.user_course_progress_model import ProgressStatus
from ..models.user_activity_model import ActivityType


class ProfileService:
    """
    Service x·ª≠ l√Ω c√°c y√™u c·∫ßu li√™n quan ƒë·∫øn profile ng∆∞·ªùi d√πng
    """

    def __init__(self, db: AsyncSession):
        self.db = db

    async def get_user_profile(self, user_id: int) -> Dict[str, Any]:
        """
        L·∫•y th√¥ng tin profile ƒë·∫ßy ƒë·ªß c·ªßa ng∆∞·ªùi d√πng t·ª´ d·ªØ li·ªáu th·ª±c trong database
        """
        # L·∫•y th√¥ng tin c∆° b·∫£n c·ªßa ng∆∞·ªùi d√πng v·ªõi user state
        result = await self.db.execute(
            select(User)
            .options(selectinload(User.state))
            .where(User.id == user_id)
        )
        user = result.scalar_one_or_none()
        if not user:
            raise ValueError("Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i")

        # L·∫•y danh s√°ch kh√≥a h·ªçc ƒë√£ ƒëƒÉng k√Ω v·ªõi progress
        enrolled_courses_result = await self.db.execute(
            select(Course, UserCourse)
            .join(UserCourse, UserCourse.course_id == Course.id)
            .where(UserCourse.user_id == user_id)
        )
        enrolled_courses = enrolled_courses_result.all()

        # L·∫•y danh s√°ch huy hi·ªáu
        badges_result = await self.db.execute(
            select(Badge, UserBadge)
            .outerjoin(
                UserBadge,
                (UserBadge.badge_id == Badge.id) & (UserBadge.user_id == user_id),
            )
        )
        badges = badges_result.all()

        # L·∫•y th·ªëng k√™ th·ª±c t·ª´ UserState
        user_state = user.state
        if user_state:
            stats = {
                "level": user_state.level,
                "completedExercises": user_state.completed_exercises,
                "completedCourses": user_state.completed_courses,
                "totalPoints": user_state.total_points,
                "streak": user_state.streak_count,
                "problems_solved": user_state.problems_solved,
            }
        else:
            # N·∫øu ch∆∞a c√≥ UserState, t·∫°o th·ªëng k√™ m·∫∑c ƒë·ªãnh
            stats = {
                "level": 1,
                "completedExercises": 0,
                "completedCourses": 0,
                "totalPoints": 0,
                "streak": 0,
                "problems_solved": 0,
            }

        # L·∫•y ti·∫øn ƒë·ªô h·ªçc t·∫≠p theo ch·ªß ƒë·ªÅ t·ª´ UserTopicProgress
        topic_progress_result = await self.db.execute(
            select(UserTopicProgress, Topic)
            .join(Topic, Topic.id == UserTopicProgress.topic_id)
            .where(UserTopicProgress.user_id == user_id)
        )
        topic_progress_data = topic_progress_result.all()

        # T·∫°o dictionary ti·∫øn ƒë·ªô h·ªçc t·∫≠p
        learning_progress = {}
        for progress, topic in topic_progress_data:
            # Map topic names to frontend keys
            topic_key = self._map_topic_to_key(topic.name)
            if topic_key:
                learning_progress[topic_key] = int(progress.progress_percentage)

        # N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu ti·∫øn ƒë·ªô, t·∫°o m·∫∑c ƒë·ªãnh
        if not learning_progress:
            learning_progress = {
                "algorithms": 0,
                "dataStructures": 0,
                "dynamicProgramming": 0,
            }

        # L·∫•y ho·∫°t ƒë·ªông g·∫ßn ƒë√¢y t·ª´ UserActivity
        activities_result = await self.db.execute(
            select(UserActivity)
            .where(UserActivity.user_id == user_id)
            .order_by(UserActivity.created_at.desc())
            .limit(10)
        )
        user_activities = activities_result.scalars().all()

        # Chuy·ªÉn ƒë·ªïi activities th√†nh format frontend
        activities = []
        for activity in user_activities:
            activity_data = {
                "id": activity.id,
                "name": activity.activity_name,
                "type": activity.activity_type.value,
                "date": activity.created_at.strftime("%d/%m/%Y"),
            }
            if activity.score is not None:
                activity_data["score"] = str(activity.score)
            if activity.progress:
                activity_data["progress"] = activity.progress
            activities.append(activity_data)

        # Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu kh√≥a h·ªçc
        courses = []
        for course, user_course in enrolled_courses:
            # T√≠nh progress d·ª±a tr√™n UserCourseProgress
            # First get total lessons
            total_result = await self.db.execute(
                select(func.count())
                .select_from(UserCourseProgress)
                .where(UserCourseProgress.user_course_id == user_course.id)
            )
            total_lessons = total_result.scalar() or 0
            
            # Then get completed lessons
            completed_result = await self.db.execute(
                select(func.count())
                .select_from(UserCourseProgress)
                .where(
                    UserCourseProgress.user_course_id == user_course.id,
                    UserCourseProgress.status == ProgressStatus.COMPLETED
                )
            )
            completed_lessons = completed_result.scalar() or 0
            
            # Calculate progress percentage
            progress = int((completed_lessons / total_lessons * 100) if total_lessons > 0 else 0)
            
            courses.append(
                {
                    "id": course.id,  # Return as int, not string
                    "name": course.title,
                    "progress": progress,
                    "colorFrom": "blue-500",  # M√†u m·∫∑c ƒë·ªãnh
                    "colorTo": "indigo-600",  # M√†u m·∫∑c ƒë·ªãnh
                }
            )

        # Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu huy hi·ªáu
        badge_list = []
        for badge, user_badge in badges:
            # UserBadge t·ªìn t·∫°i c√≥ nghƒ©a l√† user ƒë√£ c√≥ huy hi·ªáu n√†y
            has_badge = user_badge is not None
            badge_list.append(
                {
                    "id": badge.id,
                    "name": badge.name,
                    "icon": badge.icon or "üèÜ",
                    "description": badge.description,
                    "unlocked": has_badge,
                }
            )

        # T·∫°o response
        return {
            "id": user.id,
            "username": user.username,
            "fullName": user.full_name or f"{user.first_name or ''} {user.last_name or ''}".strip() or "Unknown User",
            "email": user.email,
            "avatar": user.avatar,
            "bio": user.bio or "Ch∆∞a c√≥ th√¥ng tin gi·ªõi thi·ªáu",
            "stats": stats,
            "learningProgress": learning_progress,
            "courses": courses,
            "badges": badge_list,
            "activities": activities,
        }

    def _map_topic_to_key(self, topic_name: str) -> str:
        """
        Map topic name to frontend key
        """
        topic_mapping = {
            "Thu·∫≠t to√°n c∆° b·∫£n": "algorithms",
            "Algorithms": "algorithms",
            "C·∫•u tr√∫c d·ªØ li·ªáu": "dataStructures", 
            "Data Structures": "dataStructures",
            "L·∫≠p tr√¨nh ƒë·ªông": "dynamicProgramming",
            "Dynamic Programming": "dynamicProgramming",
        }
        return topic_mapping.get(topic_name, "")

    async def add_user_activity(
        self, 
        user_id: int, 
        activity_type: ActivityType, 
        activity_name: str,
        description: str = None,
        score: int = None,
        progress: str = None,
        related_id: int = None
    ) -> UserActivity:
        """
        Th√™m ho·∫°t ƒë·ªông m·ªõi cho ng∆∞·ªùi d√πng v√† c·∫≠p nh·∫≠t th·ªëng k√™ UserState
        """
        activity = UserActivity(
            user_id=user_id,
            activity_type=activity_type,
            activity_name=activity_name,
            description=description,
            score=score,
            progress=progress,
            related_id=related_id
        )
        self.db.add(activity)
        
        # C·∫≠p nh·∫≠t UserState th·ªëng k√™
        await self._update_user_state_stats(user_id, activity_type, score)
        
        await self.db.commit()
        await self.db.refresh(activity)
        return activity

    async def update_topic_progress(
        self,
        user_id: int,
        topic_id: int,
        progress_percentage: float,
        lessons_completed: int = None,
        exercises_completed: int = None
    ) -> UserTopicProgress:
        """
        C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô h·ªçc t·∫≠p theo ch·ªß ƒë·ªÅ
        """
        # T√¨m ho·∫∑c t·∫°o m·ªõi UserTopicProgress
        result = await self.db.execute(
            select(UserTopicProgress)
            .where(
                UserTopicProgress.user_id == user_id,
                UserTopicProgress.topic_id == topic_id
            )
        )
        topic_progress = result.scalar_one_or_none()
        
        if not topic_progress:
            # T·∫°o m·ªõi
            topic_progress = UserTopicProgress(
                user_id=user_id,
                topic_id=topic_id,
                progress_percentage=progress_percentage,
                lessons_completed=lessons_completed or 0,
                exercises_completed=exercises_completed or 0
            )
            self.db.add(topic_progress)
        else:
            # C·∫≠p nh·∫≠t
            topic_progress.progress_percentage = progress_percentage
            if lessons_completed is not None:
                topic_progress.lessons_completed = lessons_completed
            if exercises_completed is not None:
                topic_progress.exercises_completed = exercises_completed
            topic_progress.last_activity_at = func.now()
        
        await self.db.commit()
        await self.db.refresh(topic_progress)
        return topic_progress

    async def _update_user_state_stats(self, user_id: int, activity_type: ActivityType, score: int = None) -> None:
        """
        C·∫≠p nh·∫≠t th·ªëng k√™ UserState khi c√≥ ho·∫°t ƒë·ªông m·ªõi
        """
        # L·∫•y ho·∫∑c t·∫°o UserState
        user_state_result = await self.db.execute(
            select(UserState).where(UserState.user_id == user_id)
        )
        user_state = user_state_result.scalar_one_or_none()

        if not user_state:
            user_state = UserState(user_id=user_id)
            self.db.add(user_state)

        # C·∫≠p nh·∫≠t th·ªëng k√™ d·ª±a tr√™n lo·∫°i ho·∫°t ƒë·ªông
        if activity_type == ActivityType.EXERCISE:
            user_state.completed_exercises += 1
            user_state.problems_solved += 1
            if score:
                user_state.total_points += score
            
        elif activity_type == ActivityType.LESSON:
            # Lesson completion gives points
            user_state.total_points += 25
            
        elif activity_type == ActivityType.COURSE:
            user_state.completed_courses += 1
            user_state.total_points += 100
            
        elif activity_type == ActivityType.BADGE:
            user_state.total_points += 50

        # C·∫≠p nh·∫≠t level n·∫øu c·∫ßn
        await self._update_level(user_state)

    async def _update_level(self, user_state: UserState) -> None:
        """
        C·∫≠p nh·∫≠t level d·ª±a tr√™n t·ªïng ƒëi·ªÉm
        """
        # Level progression: 100 points per level
        new_level = max(1, user_state.total_points // 100 + 1)
        user_state.level = new_level


def get_profile_service(db: AsyncSession = Depends(get_async_db)) -> ProfileService:
    """
    Dependency ƒë·ªÉ inject ProfileService
    """
    return ProfileService(db)
